needsPackage "SchurFunctors"

--Blueprint = new Type of HashTable --no longer used
TableauDiagram = new Type of MutableHashTable

tdFromList = method()
tdFromList (List) := TableauDiagram => L -> (
    return new TableauDiagram from hashTable L
    )

coordsFromFilling = method()
coordsFromFilling Filling := List => F -> (
    L := toList F;
    L = L/(i -> pack(2, mingle(toList(0..(#i-1)),i))); --y coords
    L = pack(2, mingle(toList(0..(#L-1)),L)); --x coords
    L = flatten (L/(i -> ({i_0} ** i_1)/flatten)); --organize into triples
    return L/(i -> (0,i_0,i_1)=>i_2) --format
    )

bdSchur = method()
bdSchur (List,Module) := Module => (p,M) -> (
    N := schurModule(p,M);
    if M.cache.?BasisDict then (
	N.cache.BasisDict = applyPairs(N.cache#"Schur"#3,
	    (k,v) -> 
	    (v,hashTable ((coordsFromFilling k)/(i -> i#0 => M.cache.BasisDict#(i#1)))))
	) else (
	N.cache.BasisDict = applyPairs(N.cache#"Schur"#3, (k,v)->(v,hashTable coordsFromFilling k))
	);
    return N
    )

--inputs to this should be outputs of bdSchur; this should NOT be directly applied to modules
bdTensor = method(Dispatch => Thing)
bdTensor Sequence := Module => L -> (
    l := #L;
    if l>1 then N := tensor L else error "tensor: input sequence length <= 1";
    BasisElts := new MutableHashTable;
    for i from 0 to l-1 do (
	BasisElts#i = (values (L_i).cache.BasisDict)/
	(h -> ((pairs h)/(m -> (i,m#0_1,m#0_2)=>m#1)))
	);
    --form list of basis elts for tensorprod
    X := tensor(toSequence apply(l, i -> BasisElts#i))/flatten/hashTable;
    N.cache.BasisDict = hashTable apply(#X, i -> i=>X_i);
    return N
    )

--the blueprint BP should be a MutableHashTable for use in straightening.
--assemble = BP -> (
--    if (class BP === Module) then return BP;
--    if #BP > 1 then return bdTensor (
--	toSequence values hashTable apply(pairs BP, (k,v) ->
--	    (k_0, bdSchur(k_1, assemble v))
--	    )
--	) else return (
--	(values hashTable apply(pairs BP, (k,v) ->
--	    (k_0, bdSchur(k_1, assemble v))
--	    ))_0
--	)
--    )

--z is tensor index of H, p is partition, M is module.
tableauStraighten = method()
tableauStraighten (ZZ, TableauDiagram, List) := {} => (z,H,p) -> (
    M := module H#(0,0,0);
    p' := toList conjugate(new Partition from p); --by columns
    cols := #p';
    tens := (ring H#(z,0,0))^1_0;
    for x from 0 to cols-1 do (
	wedge := exteriorPower(p'#x, matrix apply(p'#x, y -> H#(z,x,y))); --TODO: allow options to control which "exterior power" method is used?
	tens = tens ** (wedge_0); --wedge_0 to get wedge as module element
	);
    return ((schurModule(p,M)).cache#"Schur"#0)*tens
    )

interpret = method()
interpret Thing := {} => (H') -> (
    if not (class H' === TableauDiagram) then return H';
    H := copy H'; --safety because idk what modifies the original input
    plist := H#TableauShapes;
    for z from 0 to #plist-1 do (
	for y from 0 to #plist#z-1 do (
	    for x from 0 to plist#z#y-1 do (
		H#(z,x,y) = interpret(H#(z,x,y));
		);
	    );
	);
    tens := tableauStraighten(0,H,plist#0);
    for z from 1 to #plist-1 do (
	tens = tens ** tableauStraighten(z,H,plist#z);
	);
    return tens
    )

--X must have basis dictionary!!
schurMap = method()
schurMap (Module,Module,Function) := Matrix => (Y, X, F) -> (
    M := map(Y,0,0);
    for i from 0 to #X.cache.BasisDict-1 do (
	img := F(X.cache.BasisDict#i);
	M = M | sum(apply(#img, j -> img#j#0 * matrix(interpret(img#j#1))));
	);
    return map(Y,X,M);
    )

end--
load "Schur.m2"
